package Tut7;/** * A class of bags whose entries are stored in a fixed-size array. */public final class ArrayBag<T> implements BagInterface<T> {    //STEP 1: DETERMINES THE DATA FIELDS    /**     * TODO: Declares the necessary attributes     * bag: T[]     * numberOfEntries: int     * DEFAULT_CAPACITY: int (30)     * MAX_CAPACITY: int (3000)     */    private T[] bag;    private int numberOfEntries;    private int DEFAULT_CAPACITY = 30;    private int MAX_CAPACITY = 3000;    //STEP 2: IMPLEMENTS THE CONSTRUCTORS    /**     * TODO: Creates an empty bag with default capacity     */    public ArrayBag() {        bag = (T[]) new Object[DEFAULT_CAPACITY];    }    /**     * TODO: Creates an empty bag having a given capacity.     *     * @param desiredCapacity The integer capacity desired.     */    public ArrayBag(int desiredCapacity) {        if (desiredCapacity <= MAX_CAPACITY) {            bag = (T[]) new Object[desiredCapacity];        } else {            System.err.println("Size is too large. Bag cannot be initialized.");        }    }    //STEP 3: IMPLEMENTS THE FUNCTIONS    /**     * TODO: Adds a new entry to this bag.     *     * @param newEntry The object to be added as a new entry.     * @return True if the addition is successful, or false if not.     */    public boolean add(T newEntry) {        if (!isArrayFull()) {            numberOfEntries++;            bag[numberOfEntries - 1] = newEntry;            return true;        }        return false;    }    /**     * TODO: Retrieves all entries that are in this bag.     *     * @return A newly allocated array of all the entries in this bag.     */    public T[] toArray() {        return bag.clone();    }    /**     * TODO: Sees whether this bag is empty.     *     * @return True if this bag is empty, or false if not.     */    public boolean isEmpty() {        return numberOfEntries == 0;    }    /**     * TODO: Gets the current number of entries in this bag.     *     * @return The integer number of entries currently in this bag.     */    public int getCurrentSize() {        return numberOfEntries;    }    /**     * TODO: Counts the number of times a given entry appears in this bag.     *     * @param anEntry The entry to be counted.     * @return The number of times anEntry appears in this bag.     */    public int getFrequencyOf(T anEntry) {        int freq = 0;        if (!isEmpty()) {            for (int i = 0; i < getCurrentSize(); i++) {                if (bag[i].equals(anEntry)) {                    freq++;                }            }        }        return freq;    }    /**     * TODO: Tests whether this bag contains a given entry.     *     * @param anEntry The entry to locate.     * @return True if this bag contains anEntry, or false otherwise.     */    public boolean contains(T anEntry) {        if (!isEmpty()) {            for (int i = 0; i < getCurrentSize(); i++) {                if (bag[i].equals(anEntry)) {                    return true;                }            }        }        return false;    }    /**     * TODO: Removes all entries from this bag.     */    public void clear() {        numberOfEntries = 0;    }    /**     * TODO: Removes one unspecified entry from this bag, if possible.     *     * @return Either the removed entry, if the removal was successful, or null.     */    public T remove() {        if (!isEmpty()) {            int currentIndex = numberOfEntries - 1;            T removedEntry = removeEntry(currentIndex);            numberOfEntries--;            return removedEntry;        }        return null;    }    /**     * TODO: Removes one occurrence of a given entry from this bag.     *     * @param anEntry The entry to be removed.     * @return True if the removal was successful, or false if not.     */    public boolean remove(T anEntry) {        if (!isEmpty()) {            int removingEntryIndex = getIndexOf(anEntry);            if (removingEntryIndex != -1) {                T removedEntry = removeEntry(removingEntryIndex);                numberOfEntries--;                if (removedEntry != null) {                    return true;                }            }        }        return false;    }    // TODO: Returns true if the array bag is full, or false if not.    private boolean isArrayFull() {        return getCurrentSize() == bag.length;    }    // TODO: Locates a given entry within the array bag.    // Returns the index of the entry, if located,    // or -1 otherwise.    // Precondition: checkInitialization has been called.    private int getIndexOf(T anEntry) {        int index = -1;        if (!isEmpty()) {            for (int i = 0; i < getCurrentSize(); i++) {                if (bag[i].equals(anEntry)) {                    index = i;                    break;                }            }        }        return index;    }    // TODO: Removes and returns the entry at a given index within the array.    // If no such entry exists, returns null.    // Precondition: 0 <= givenIndex < numberOfEntries.    // Precondition: checkInitialization has been called.    private T removeEntry(int givenIndex) {        if (!isEmpty() && 0 <= givenIndex && givenIndex < getCurrentSize()) {            T entry = bag[givenIndex];            for (int i = givenIndex; i < getCurrentSize() - 1; i++) {                bag[i] = bag[i + 1];            }            return entry;        }        return null;    }}